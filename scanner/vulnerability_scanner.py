from zapv2 import ZAPv2
import json
import time
import os
import subprocess
from datetime import datetime

# === Configuration ===
API_KEY = os.getenv('ZAP_API_KEY', '')  # Optional API key
ZAP_PROXY = {'http': 'http://localhost:8080', 'https': 'http://localhost:8080'}
TARGET_URL = 'http://localhost:3000'  # Juice Shop URL
OUTPUT_FILE = f"zap_scan_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

# SQLMap Configuration
SQLMAP_PATH = "/usr/bin/sqlmap"  # Path to SQLMap executable

# === Initialize ZAP Client ===
zap = ZAPv2(apikey=API_KEY, proxies=ZAP_PROXY)

def scan_with_retry(func, url, max_retries=3):
    """Helper function with retry logic for scan initiation"""
    for attempt in range(max_retries):
        try:
            return func(url)
        except Exception as e:
            if attempt < max_retries - 1:
                print(f"Retrying ({attempt + 1}/{max_retries})...")
                time.sleep(2)
                continue
            raise e

def enable_specific_zap_scanners():
    """Enable only the ZAP scan rules for the new OWASP Top 10 vulnerabilities"""
    # Disable all scanners first
    zap.ascan.disable_all_scanners()

    # Enable specific scanners based on their IDs
    scanners_to_enable = [
        # Broken Access Control
        "40001",  # Session Fixation
        "40003",  # Weak Authentication
        # Cryptographic Failures
        "40023",  # Insecure TLS/SSL Configuration
        # Injection (SQL Injection)
        "40018",  # SQL Injection (Hypersonic)
        "40019",  # SQL Injection (MySQL)
        "40020",  # SQL Injection (Oracle)
        "40021",  # SQL Injection (PostgreSQL)
        "40022",  # SQL Injection (SQLite)
        # Insecure Design
        # Note: ZAP does not have specific scanners for Insecure Design, but you can check for common issues manually.
        # Security Misconfiguration
        "40016",  # Insecure HTTP Methods
        "40024",  # Application Error Disclosure
    ]

    for scanner_id in scanners_to_enable:
        zap.ascan.enable_scanners(scanner_id)

    print("Enabled specific ZAP scanners for Broken Access Control, Cryptographic Failures, Injection, and Security Misconfiguration.")

def zap_security_scan():
    """Run OWASP ZAP to detect specific vulnerabilities"""
    print(f"\n=== Initiating spider scan on: {TARGET_URL} ===")
    zap.spider.scan(TARGET_URL, maxchildren=10, recurse=True)
    
    while int(zap.spider.status()) < 100:
        print(f"Spider progress: {zap.spider.status()}%")
        time.sleep(2)
    
    print("Spider scan completed!\n")
    
    print("=== Starting active scan ===")
    zap.ascan.scan(TARGET_URL)
    
    while int(zap.ascan.status()) < 100:
        print(f"Active scan progress: {zap.ascan.status()}%")
        time.sleep(5)

    print("Active scan completed!\n")

    # Retrieve alerts (vulnerabilities) found during the scan
    alerts = zap.core.alerts(baseurl=TARGET_URL)
    with open(OUTPUT_FILE, 'w') as f:
        json.dump(alerts, f, indent=4)

    print(f"Scan results saved to {OUTPUT_FILE}")
    print(f"Found {len(alerts)} potential vulnerabilities")

def sql_injection_scan():
    """Use SQLMap to detect SQL Injection vulnerabilities"""
    if not os.path.exists(SQLMAP_PATH):
        print("SQLMap not found! Skipping SQL Injection scan.")
        return
    
    print("\n=== Running SQLMap for SQL Injection Detection ===")
    endpoints = [
        "http://localhost:3000/rest/products/search?q=test",
        "http://localhost:3000/rest/user/login"
    ]
    for endpoint in endpoints:
        command = [SQLMAP_PATH, "-u", endpoint, "--batch", "--dbs"]
        try:
            result = subprocess.run(command, capture_output=True, text=True, timeout=300)
            if "does not seem to be injectable" in result.stdout:
                print(f"No SQL Injection vulnerabilities found in {endpoint}.")
            else:
                print(f"Possible SQL Injection vulnerabilities detected in {endpoint}!")
                print(result.stdout)
        except subprocess.TimeoutExpired:
            print(f"SQLMap scan timed out for {endpoint}.")

def xss_scan():
    """Perform XSS scan using ZAP's XSS scanners"""
    print("\n=== Performing XSS Scan ===")
    zap.ascan.enable_scanners("40012")  # Reflected XSS
    zap.ascan.enable_scanners("40013")  # Persistent XSS
    zap.ascan.enable_scanners("40014")  # DOM-based XSS
    zap.ascan.scan(TARGET_URL)
    
    while int(zap.ascan.status()) < 100:
        print(f"XSS scan progress: {zap.ascan.status()}%")
        time.sleep(5)
    
    alerts = zap.core.alerts(baseurl=TARGET_URL)
    xss_alerts = [alert for alert in alerts if "Cross-Site Scripting" in alert.get("name", "")]
    print(f"Found {len(xss_alerts)} XSS vulnerabilities.")

if __name__ == "__main__":
    print("=== Running Web Security Scanner ===")
    enable_specific_zap_scanners()  # Enable only specific scanners
    zap_security_scan()  # Run ZAP scan
    sql_injection_scan()  # Run SQLMap for SQL Injection
    xss_scan()  # Perform XSS scan

    print("\n=== Scan Complete! ===")
